cases_df <- data.frame(x = coords[, "X"], y = coords[, "Y"])
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
coord_fixed()
sigma <- bw.diggle(cases_ppp)
density_estimate <- density(cases_ppp, sigma = 75)
density_raster <- raster(density_estimate)
df <- as.data.frame(rasterToPoints(density_raster))
colnames(df) <- c("x", "y", "intensity")
cases_df <- data.frame(x = coords[, "X"], y = coords[, "Y"])
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
coord_fixed()
sigma <- bw.diggle(cases_ppp)
density_estimate <- density(cases_ppp, sigma = 50)
density_raster <- raster(density_estimate)
df <- as.data.frame(rasterToPoints(density_raster))
colnames(df) <- c("x", "y", "intensity")
cases_df <- data.frame(x = coords[, "X"], y = coords[, "Y"])
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
coord_fixed()
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_sf(data = shelters_projected, color = "red", shape = 20, size = 4) +
geom_tile() +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
coord_fixed()
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
coord_fixed()
View(df)
View(shelters_projected)
View(shelters)
View(shelters_projected)
shelters_projected$geometry
st_coordinates(shelters_projected)
# overlay shelter points
coords_shelter <- st_coordinates(shelters_projected)
shelter_df <- data.frame(x = coords[, "X"], y = coords[, "Y"])
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_point(shelter_df, aes(x = x, y = y)) +
geom_tile() +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
coord_fixed()
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_point(shelter_df) +
geom_tile() +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
coord_fixed()
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
coord_fixed()
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +
geom_point(data = shelter_df, aes(x = X, y = Y), color = "red", size = 3) +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
coord_fixed()
View(shelter_df)
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +
geom_point(data = shelter_df, aes(x = x, y = y), color = "red", size = 3) +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
coord_fixed()
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
geom_point(data = shelter_df, aes(x = x, y = y), color = "red", size = 3) +
coord_fixed()
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +
scale_fill_viridis_c() +
theme_minimal() +
#labs(fill = "Intensity") +
geom_point(data = shelter_df, aes(x = x, y = y), color = "red", size = 3) +
coord_fixed()
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
coord_fixed()
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +  # This creates the intensity plot
geom_point(data = shelter_df, aes(x = X, y = Y), color = "red", size = 3) +  # Add the shelter points on top
scale_fill_viridis_c() +  # Color scale for the intensity
theme_minimal() +  # Minimal theme for the plot
labs(fill = "Intensity") +  # Label for the color legend
coord_fixed()  # Keep aspect ratio fixed
ggplot(df, aes(x = x, y = y, fill = intensity)) +
geom_tile() +  # This creates the intensity plot
geom_point(data = shelter_df, aes(x = x, y = y), color = "red", size = 3) +  # Add the shelter points on top
scale_fill_viridis_c() +  # Color scale for the intensity
theme_minimal() +  # Minimal theme for the plot
labs(fill = "Intensity") +  # Label for the color legend
coord_fixed()  # Keep aspect ratio fixed
ggplot() +
geom_tile(data = df, aes(x = x, y = y, fill = intensity)) +  # Add intensity plot
geom_point(data = shelter_df, aes(x = X, y = Y), color = "red", size = 3) +  # Overlay shelter points
scale_fill_viridis_c() +  # Color scale for intensity
theme_minimal() +  # Use a minimal theme
labs(fill = "Intensity") +  # Label for the color legend
coord_fixed()  # Use a fixed aspect ratio
ggplot() +
geom_tile(data = df, aes(x = x, y = y, fill = intensity)) +  # Add intensity plot
geom_point(data = shelter_df, aes(x = x, y = y), color = "red", size = 3) +  # Overlay shelter points
scale_fill_viridis_c() +  # Color scale for intensity
theme_minimal() +  # Use a minimal theme
labs(fill = "Intensity") +  # Label for the color legend
coord_fixed()  # Use a fixed aspect ratio
# overlay shelter points
coords_shelter <- st_coordinates(shelters_projected)
shelter_df <- data.frame(x = coords_shelter[, "X"], y = coords_shelter[, "Y"])
ggplot() +
geom_tile(data = df, aes(x = x, y = y, fill = intensity)) +  # Add intensity plot
geom_point(data = shelter_df, aes(x = x, y = y), color = "red", size = 3) +  # Overlay shelter points
scale_fill_viridis_c() +  # Color scale for intensity
theme_minimal() +  # Use a minimal theme
labs(fill = "Intensity") +  # Label for the color legend
coord_fixed()  # Use a fixed aspect ratio
library(sf)
library(spatstat)
library(ggplot2)
library(raster)
library(dplyr)
library(cubature)
distances
min_distances
clear
nrow(cases_df)
length(min_distances)
as.data.frame(distances)
dists <- as.data.frame(distances)
dists$V1
View(cases_df)
cases_df
cases_df[,1]
min(cases_df[,1])
max(cases_df[,1])
min(cases_df[,2])
max(cases_df[,2])
s1 <- c(552176.6, 4181576)
s2 <- c(552087.9, 4181425)
s3 <- c(551821.3, 4181152)
s4 <- c(552029.7, 4181720)
dist_s1 <- sqrt( (cases_df[,1] - s1[1])^2 + (cases_dt[,2]-s1[2])^2 )
s1 <- c(552176.6, 4181576)
s2 <- c(552087.9, 4181425)
s3 <- c(551821.3, 4181152)
s4 <- c(552029.7, 4181720)
dist_s1 <- sqrt( (cases_df[,1] - s1[1])^2 + (cases_df[,2]-s1[2])^2 )
llik <- function(theta) {
alpha <- theta[1]
beta <- theta[2]
f_int <- function(x) { # the fn that needs to be numerically integrated
d1 <- sqrt( (x[1] - c1[1])^2 + (x[2]-c1[2])^2 )
(1 + alpha * exp(-beta * d1))
}
int_v <- cubature::adaptIntegrate(f_int, c(551253.5,4180761), c(552689.7,4182178))$integral
# use negative of llik so we can do minimization
-sum(log((1 + alpha * exp(-beta * dist_c1))*(1 + alpha * exp(-beta * dist_c2)))) + n*log(int_v)
}
optim(c(1,1), llik)
s1 <- c(552176.6, 4181576)
s2 <- c(552087.9, 4181425)
s3 <- c(551821.3, 4181152)
s4 <- c(552029.7, 4181720)
dist_s1 <- sqrt( (cases_df[,1] - s1[1])^2 + (cases_df[,2]-s1[2])^2 )
llik <- function(theta) {
alpha <- theta[1]
beta <- theta[2]
f_int <- function(x) { # the fn that needs to be numerically integrated
d1 <- sqrt( (x[1] - s1[1])^2 + (x[2]-s1[2])^2 )
(1 + alpha * exp(-beta * d1))
}
int_v <- cubature::adaptIntegrate(f_int, c(551253.5,4180761), c(552689.7,4182178))$integral
# use negative of llik so we can do minimization
-sum(log((1 + alpha * exp(-beta * dist_c1))*(1 + alpha * exp(-beta * dist_c2)))) + n*log(int_v)
}
optim(c(1,1), llik)
s1 <- c(552176.6, 4181576)
s2 <- c(552087.9, 4181425)
s3 <- c(551821.3, 4181152)
s4 <- c(552029.7, 4181720)
dist_s1 <- sqrt( (cases_df[,1] - s1[1])^2 + (cases_df[,2]-s1[2])^2 )
llik <- function(theta) {
alpha <- theta[1]
beta <- theta[2]
f_int <- function(x) { # the fn that needs to be numerically integrated
d1 <- sqrt( (x[1] - s1[1])^2 + (x[2]-s1[2])^2 )
(1 + alpha * exp(-beta * d1))
}
int_v <- cubature::adaptIntegrate(f_int, c(551253.5,4180761), c(552689.7,4182178))$integral
# use negative of llik so we can do minimization
-sum(log((1 + alpha * exp(-beta * dist_s1)))) + n*log(int_v)
}
optim(c(1,1), llik)
s1 <- c(552176.6, 4181576)
s2 <- c(552087.9, 4181425)
s3 <- c(551821.3, 4181152)
s4 <- c(552029.7, 4181720)
dist_s1 <- sqrt( (cases_df[,1] - s1[1])^2 + (cases_df[,2]-s1[2])^2 )
llik <- function(theta) {
alpha <- theta[1]
beta <- theta[2]
f_int <- function(x) { # the fn that needs to be numerically integrated
d1 <- sqrt( (x[1] - s1[1])^2 + (x[2]-s1[2])^2 )
(1 + alpha * exp(-beta * d1))
}
int_v <- adaptIntegrate(f_int, c(551253.5,4180761), c(552689.7,4182178))$integral
# use negative of llik so we can do minimization
-sum(log((1 + alpha * exp(-beta * dist_s1)))) + n*log(int_v)
}
optim(c(1,1), llik)
dist_s1
s1 <- c(552176.6, 4181576)
s2 <- c(552087.9, 4181425)
s3 <- c(551821.3, 4181152)
s4 <- c(552029.7, 4181720)
dist_s1 <- sqrt( (cases_df[,1] - s1[1])^2 + (cases_df[,2]-s1[2])^2 )
llik <- function(theta) {
alpha <- theta[1]
beta <- theta[2]
f_int <- function(x) { # the fn that needs to be numerically integrated
d1 <- sqrt( (x[1] - s1[1])^2 + (x[2]-s1[2])^2 )
(1 + alpha * exp(-beta * d1))
}
int_v <- adaptIntegrate(f_int, c(551253.5,4180761), c(552689.7,4182178))$integral
print(int_v)
# use negative of llik so we can do minimization
-sum(log((1 + alpha * exp(-beta * dist_s1)))) + n*log(int_v)
}
optim(c(1,1), llik)
log(2035095)
n <- nrow(cases_df)
s1 <- c(552176.6, 4181576)
s2 <- c(552087.9, 4181425)
s3 <- c(551821.3, 4181152)
s4 <- c(552029.7, 4181720)
dist_s1 <- sqrt( (cases_df[,1] - s1[1])^2 + (cases_df[,2]-s1[2])^2 )
llik <- function(theta) {
alpha <- theta[1]
beta <- theta[2]
f_int <- function(x) { # the fn that needs to be numerically integrated
d1 <- sqrt( (x[1] - s1[1])^2 + (x[2]-s1[2])^2 )
(1 + alpha * exp(-beta * d1))
}
int_v <- adaptIntegrate(f_int, c(551253.5,4180761), c(552689.7,4182178))$integral
print(int_v)
# use negative of llik so we can do minimization
-sum(log((1 + alpha * exp(-beta * dist_s1)))) + n*log(int_v)
}
optim(c(1,1), llik)
n <- nrow(cases_df)
s1 <- c(552176.6, 4181576)
s2 <- c(552087.9, 4181425)
s3 <- c(551821.3, 4181152)
s4 <- c(552029.7, 4181720)
dist_s1 <- sqrt( (cases_df[,1] - s1[1])^2 + (cases_df[,2]-s1[2])^2 )
llik <- function(theta) {
alpha <- theta[1]
beta <- theta[2]
f_int <- function(x) { # the fn that needs to be numerically integrated
d1 <- sqrt( (x[1] - s1[1])^2 + (x[2]-s1[2])^2 )
(1 + alpha * exp(-beta * d1))
}
int_v <- adaptIntegrate(f_int, c(551253.5,4180761), c(552689.7,4182178))$integral
# use negative of llik so we can do minimization
-sum(log((1 + alpha * exp(-beta * dist_s1)))) + n*log(int_v)
}
optim(c(1,1), llik)
f_int_est <- function(x) {
d1 <- sqrt( (x[1] - s1[1])^2 + (x[2]-s1[2])^2 )
(1 + 1.1 * exp(d1)))
f_int_est <- function(x) {
d1 <- sqrt( (x[1] - s1[1])^2 + (x[2]-s1[2])^2 )
(1 + 1.1 * exp(d1))
}
rho_est <- n / adaptIntegrate(f_int_est, c(551253.5,4180761), c(552689.7,4182178))$integral
rho_est
adaptIntegrate(f_int_est, c(551253.5,4180761), c(552689.7,4182178))$integral
f_int_est <- function(x) {
d1 <- sqrt( (x[1] - s1[1])^2 + (x[2]-s1[2])^2 )
(1 + 1.1 * exp(-d1))
}
rho_est <- n / adaptIntegrate(f_int_est, c(551253.5,4180761), c(552689.7,4182178))$integral
rho_est
ggplot() +
geom_sf(data = study_region_projected, fill = 'lightblue', color = 'black', size = 0.5, alpha = 0.5) +
geom_sf(data = cases_projected, color = 'orange', size = 2) +
geom_sf(data = shelters_projected, color = 'red', size = 4) +
labs(title = "Projected Study Region with Cases",
subtitle = "Red points represent cases, Blue points present shelters",
x = "Longitude", y = "Latitude") +
theme_minimal() +
theme(axis.title = element_text(size = 12),
plot.title = element_text(size = 14, face = "bold"),
plot.subtitle = element_text(size = 12))
ggplot() +
geom_sf(data = study_region_projected, fill = 'lightblue', color = 'black', size = 0.5, alpha = 0.5) +
geom_sf(data = cases_projected, color = 'purple', size = 2) +
geom_sf(data = shelters_projected, color = 'red', size = 4) +
labs(title = "Projected Study Region with Cases",
subtitle = "Red points represent cases, Blue points present shelters",
x = "Longitude", y = "Latitude") +
theme_minimal() +
theme(axis.title = element_text(size = 12),
plot.title = element_text(size = 14, face = "bold"),
plot.subtitle = element_text(size = 12))
ggplot() +
geom_tile(data = df, aes(x = x, y = y, fill = intensity)) +
geom_point(data = shelter_df, aes(x = x, y = y), color = "red", size = 3) +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
labs(title = "Map of Homelessness Cases and Shelters",
subtitle = "Cases colored by distance to the nearest shelter",
x = "Longitude", y = "Latitude") +
coord_fixed()
ggplot() +
geom_tile(data = df, aes(x = x, y = y, fill = intensity)) +
geom_point(data = shelter_df, aes(x = x, y = y), color = "red", size = 3) +
scale_fill_viridis_c() +
theme_minimal() +
labs(fill = "Intensity") +
labs(title = "Intensity Plot",
subtitle = "Red points represent shelters",
x = "Longitude", y = "Latitude") +
coord_fixed()
min_distances
as.data.frame(min_distances)
dists <- as.data.frame(min_distances)
dists
dists <- as.data.frame(min_distances)
dists
n <- nrow(cases_df)
dists <- as.data.frame(min_distances)
s1 <- c(552176.6, 4181576)
s2 <- c(552087.9, 4181425)
s3 <- c(551821.3, 4181152)
s4 <- c(552029.7, 4181720)
llik <- function(theta) {
alpha <- theta[1]
beta <- theta[2]
f_int <- function(x) { # the fn that needs to be numerically integrated
d1 <- sqrt( (x[1] - s1[1])^2 + (x[2]-s1[2])^2 )
(1 + alpha * exp(-beta * d1))
}
int_v <- adaptIntegrate(f_int, c(551253.5,4180761), c(552689.7,4182178))$integral
# use negative of llik so we can do minimization
-sum(log((1 + alpha * exp(-beta * dists)))) + n*log(int_v)
}
optim(c(1,1), llik)
n <- nrow(cases_df)
dists <- as.data.frame(min_distances)
s1 <- c(552176.6, 4181576)
s2 <- c(552087.9, 4181425)
s3 <- c(551821.3, 4181152)
s4 <- c(552029.7, 4181720)
llik <- function(theta) {
alpha <- theta[1]
beta <- theta[2]
f_int <- function(x) { # the fn that needs to be numerically integrated
d1 <- sqrt((x[1] - s1[1])^2 + (x[2] - s1[2])^2)
d2 <- sqrt((x[1] - s2[1])^2 + (x[2] - s2[2])^2)
d3 <- sqrt((x[1] - s3[1])^2 + (x[2] - s3[2])^2)
d4 <- sqrt((x[1] - s4[1])^2 + (x[2] - s4[2])^2)
d_min <- min(d1, d2, d3, d4)
(1 + alpha * exp(-beta * d_min))
}
int_v <- adaptIntegrate(f_int, c(551253.5,4180761), c(552689.7,4182178))$integral
# use negative of llik so we can do minimization
-sum(log((1 + alpha * exp(-beta * dists)))) + n*log(int_v)
}
optim(c(1,1), llik)
f_int_est <- function(x) {
d1 <- sqrt((x[1] - s1[1])^2 + (x[2] - s1[2])^2)
d2 <- sqrt((x[1] - s2[1])^2 + (x[2] - s2[2])^2)
d3 <- sqrt((x[1] - s3[1])^2 + (x[2] - s3[2])^2)
d4 <- sqrt((x[1] - s4[1])^2 + (x[2] - s4[2])^2)
d_min <- min(d1, d2, d3, d4)
(1 + alpha * exp(-beta * d_min))
}
rho_est <- n / adaptIntegrate(f_int_est, c(551253.5,4180761), c(552689.7,4182178))$integral
f_int_est <- function(x) {
d1 <- sqrt((x[1] - s1[1])^2 + (x[2] - s1[2])^2)
d2 <- sqrt((x[1] - s2[1])^2 + (x[2] - s2[2])^2)
d3 <- sqrt((x[1] - s3[1])^2 + (x[2] - s3[2])^2)
d4 <- sqrt((x[1] - s4[1])^2 + (x[2] - s4[2])^2)
d_min <- min(d1, d2, d3, d4)
(1 + 1.1 * exp(-d_min))
}
rho_est <- n / adaptIntegrate(f_int_est, c(551253.5,4180761), c(552689.7,4182178))$integral
rho_est
f_int_est <- function(x) {
d1 <- sqrt((x[1] - s1[1])^2 + (x[2] - s1[2])^2)
d2 <- sqrt((x[1] - s2[1])^2 + (x[2] - s2[2])^2)
d3 <- sqrt((x[1] - s3[1])^2 + (x[2] - s3[2])^2)
d4 <- sqrt((x[1] - s4[1])^2 + (x[2] - s4[2])^2)
d_min <- min(d1, d2, d3, d4)
(1 + 1.1 * exp(-d1))
}
rho_est <- n / adaptIntegrate(f_int_est, c(551253.5,4180761), c(552689.7,4182178))$integral
rho_est
f_int_est <- function(x) {
d1 <- sqrt((x[1] - s1[1])^2 + (x[2] - s1[2])^2)
d2 <- sqrt((x[1] - s2[1])^2 + (x[2] - s2[2])^2)
d3 <- sqrt((x[1] - s3[1])^2 + (x[2] - s3[2])^2)
d4 <- sqrt((x[1] - s4[1])^2 + (x[2] - s4[2])^2)
d_min <- min(d1, d2, d3, d4)
(1 + 1.1 * exp(-d_min))
}
rho_est <- n / adaptIntegrate(f_int_est, c(551253.5,4180761), c(552689.7,4182178))$integral
rho_est
View(df)
View(study_region)
View(study_region_projected)
bbox(study_region_projected)
bbox(study_region_projected$geometry)
bbox(study_region_projected$geometry[1])
st_bbox(study_region_projected)
bounds <- st_bbox(study_region_projected)
bounds
bounds <- st_bbox(study_region_projected)
bounds
study_region_polygon <- study_region_projected
# Your likelihood function
llik <- function(theta) {
alpha <- theta[1]
beta <- theta[2]
# The function to be integrated
f_int <- function(x) {
point <- st_point(x)
# Check if the point is within the study region polygon
if (!st_contains(study_region_polygon, point, sparse = FALSE)) {
return(0)
}
# Calculate distances to each shelter and find the minimum
d <- sapply(list(s1, s2, s3, s4), function(s) {
st_distance(point, st_point(s))
})
min_d <- min(d)
# Return the intensity function value for the given point
return(1 + alpha * exp(-beta * min_d))
}
# The bounds for the numerical integration
bounds <- st_bbox(study_region_polygon)
# Perform the integration
int_v <- adaptIntegrate(f_int, lower = c(bounds['xmin'], bounds['ymin']),
upper = c(bounds['xmax'], bounds['ymax']))$integral
# Calculate the log likelihood
n <- nrow(cases_df) # assuming cases_df is your data frame with cases
-sum(log((1 + alpha * exp(-beta * dists$min_distance)))) + n * log(int_v)
}
# Initial parameters for optimization
theta_init <- c(1, 1)
# Optimization step
optim_results <- optim(theta_init, llik)
study_region_polygon <- study_region_projected
bounds <- st_bbox(study_region_polygon)
n <- nrow(cases_df)
llik <- function(theta) {
alpha <- theta[1]
beta <- theta[2]
f_int <- function(x) {
point <- st_point(x)
if (!st_contains(study_region_polygon, point, sparse = FALSE)) {
return(0)
}
d1 <- sqrt((x[1] - s1[1])^2 + (x[2] - s1[2])^2)
d2 <- sqrt((x[1] - s2[1])^2 + (x[2] - s2[2])^2)
d3 <- sqrt((x[1] - s3[1])^2 + (x[2] - s3[2])^2)
d4 <- sqrt((x[1] - s4[1])^2 + (x[2] - s4[2])^2)
d_min <- min(d1, d2, d3, d4)
(1 + alpha * exp(-beta * d_min))
}
# Perform the integration
int_v <- adaptIntegrate(f_int, lower = c(bounds['xmin'], bounds['ymin']),
upper = c(bounds['xmax'], bounds['ymax']))$integral
# Calculate the log likelihood
-sum(log((1 + alpha * exp(-beta * dists)))) + n * log(int_v)
}
# Initial parameters for optimization
theta_init <- c(1, 1)
# Optimization step
optim_results <- optim(theta_init, llik)
